def plot_roi(roi_img, bg_img=None, cut_coords=5, output_file=None, display_mode='mosaic', figure=None, axes=None,
             title=None, annotate=True, draw_cross=True, black_bg=True, threshold=0.5, alpha=0.7,
             cmap='tab10', dim='auto', vmin=None, vmax=None, resampling_interpolation='nearest', view_type='continuous',
             linewidths=2.5, colorbar=False, save_img=True, **kwargs):
    """

    Wrapper for nilearn's plot_roi method (with small modifications).

    Can be used in a nipype function node. In this case output_file should stay None and save_img should stay True!

    Parameters:
        Only parameter that does not occur in nilearn's plot_roi method is save_img.
        Set to False if you don't want to save the result and just need the plot object.
        This parameter is necessary because we substitute output_file by the current working directory and a suitable
        filename if output_file is set to None (default).
        In case the function is executed within a nipype function node, the current working directory is the working
        directory of the respective node.
        We introduced this modifications in order to be able to use this method easily in nipype function nodes.

    For more information about the other parameters, see the documentation of nilearn.
    https://nilearn.github.io/modules/generated/nilearn.plotting.plot_roi.html

    Only a few changes have been made to the default parameters.
    Here a mosaic plot with 5 columns is generated by default, the background of every plot is black and the default
    cmap has been changed.

    ATTENTION: If save_img is set to False, then you must close the plot yourself!
    Otherwise this could lead to memory leaks!

    Returns:
        plot (nilearn.plotting.displays.OrthoSlicer): Plot object.
        output_file (str): Path to the saved plot (if save_img is False, None is returned).

    Acknowledgements:
        Further informations:
            - https://nilearn.github.io/index.html

    """
    from nilearn import plotting
    import os

    if save_img:
        # User wants to save the image directly and doesn't want to only get the plot object to modify it further
        # before saving.
        if output_file is None:
            roi_img_name = roi_img.split('/')[-1].split('.')[0]  # Get filename without extension.
            # Plot will be saved in current working directory with the filename (without extension) of ROI image.
            # but with the suffix '_plot.png'
            output_file = os.path.join(os.getcwd(), roi_img_name + '_plot.png')
        else:
            # If the user has specified an absolute path, then we can directly use it.
            # If we have only received a relative path, then we append this relative path to the current working
            # directory.
            if not output_file.startswith('/'):
                output_file = os.path.join(os.getcwd(), output_file)
    else:
        output_file = None
        # If output_file is None, then nilearn won't save the image.
        # In this case, the user must close the plot themself! Otherwise this could lead to memory leaks!

    plot = plotting.plot_roi(roi_img, bg_img=bg_img, cut_coords=cut_coords, output_file=output_file,
                             display_mode=display_mode, figure=figure, axes=axes, title=title, annotate=annotate,
                             draw_cross=draw_cross,
                             black_bg=black_bg, threshold=threshold, alpha=alpha, cmap=cmap, dim=dim, vmin=vmin,
                             vmax=vmax, resampling_interpolation=resampling_interpolation, view_type=view_type,
                             linewidths=linewidths, colorbar=colorbar, **kwargs)

    return plot, output_file


def segmentation_qc_plot(overlay, bg_img=None, output_file=None, cut_coords=5, cmap='winter', **kwargs):
    """

    Create segmentation (e.g. brain extraction, tissue segmentation) quality check images.

    Can be used in a nipype function node. In this case output_file should stay None!

    Parameters:
        overlay (str): Path to the overlay (e.g. in brain extraction workflows the extracted brain).
        bg_img (str): Path to the background (e.g. in brain extraction workflows the head).
        output_file (str): Filename of quality check image. Can be be an absolute path or a relative path.
                           If it's set to None (default), the filename is automatically generated.
        cmap (matplotlib colormap): Colormap.
        **kwargs: These parameters are passed to the plot_roi method.

    Returns:
        output_file (str): Path to the saved plot.

    """
    from PUMI.utils.plotting import plot_roi

    plot, output_file = plot_roi(roi_img=overlay, bg_img=bg_img, output_file=output_file, cut_coords=cut_coords,
                                 cmap=cmap, **kwargs)
    return output_file


def coregistration_qc_plot(registered_brain, template, output_file=None, levels=None, cmap='winter', **kwargs):
    """

    Create coregistration quality check images.

    Can be used in a nipype function node. In this case output_file should stay None!

    Parameters
    ----------
    registered_brain (str): Path to the registered brain.
    template (str): Path to the used template (reference) file.
    output_file (str): Filename of quality check image. Can be be an absolute path or a relative path.
                       If it's set to None (default), the path and filename is automatically generated.
    levels (list): Contour fillings levels. If set to None, [0.5] will be used.
    cmap (matplotlib colormap): Colormap.
    **kwargs: These parameters are passed to plot_roi method.

    Returns
    ----------
    output_file (str): Path to the saved plot.

    """
    from PUMI.utils.plotting import plot_roi
    import os

    if levels is None:
        levels = [0.5]

    plot, _ = plot_roi(roi_img=registered_brain, bg_img=template, cmap=cmap, alpha=0, save_img=False, **kwargs)
    plot.add_contours(registered_brain, levels=levels, colors='r')

    if output_file is None:
        registered_brain_filename = registered_brain.split('/')[-1].split('.')[0]
        output_file = os.path.join(os.getcwd(), registered_brain_filename + '_plot.png')
    else:
        if not output_file.startswith('/'):
            output_file = os.path.join(os.getcwd(), output_file)

    plot.savefig(output_file)
    plot.close()

    return output_file


def timeseries_carpet_plot(timeseries, modules, atlas=None, background_file=None, subplot=None, output_file="regts.png"):
    """
    Adapted from: https://github.com/poldracklab/niworkflows
    Plot an image representation of voxel intensities across time also know
    as the "carpet plot" or "Power plot". See Jonathan Power Neuroimage
    2017 Jul 1; 154:150-158.
    Parameters:
        timeseries (numpy.ndarray): 4D input image. See http://nilearn.github.io/manipulating_images/input_output.html.
        output_file (str, None): Optional! The name of the output image. Valid extensions are .png, .pdf, .svg.
    """
    import numpy as np
    import nibabel as nb
    import pandas as pd
    import os
    import matplotlib.pyplot as plt
    from matplotlib import gridspec as mgs
    import matplotlib.cm as cm
    from matplotlib.colors import ListedColormap
    from nilearn.plotting import plot_img

    legend = False
    if atlas:
        legend = True

    # actually load data
    timeseries = pd.read_csv(timeseries, sep="\t")

    #normalise all timeseries
    v = (None, None)
    timeseries = (timeseries - timeseries.mean()) / timeseries.std()
    v = (-2, 2)
    timeseries = timeseries.transpose()

    minimum = timeseries.min()
    maximum = timeseries.max()
    myrange = maximum - minimum

    modules = pd.Series(modules).values
    lut = pd.factorize(modules)[0]+1

    # If subplot is not defined
    if subplot is None:
        subplot = mgs.GridSpec(1, 1)[0]

    # Define nested GridSpec
    wratios = [2, 120, 20]
    gs = mgs.GridSpecFromSubplotSpec(1, 2 + int(legend), subplot_spec=subplot,
                                     width_ratios=wratios[:2 + int(legend)],
                                     wspace=0.0)

    mycolors = ListedColormap(cm.get_cmap('Set1').colors[:7][::-1])

    # Segmentation colorbar

    ax0 = plt.subplot(gs[0])

    ax0.set_yticks([])
    ax0.set_xticks([])

    lutt=pd.DataFrame({'1': lut})
    ax0.imshow(lutt, interpolation='none', aspect='auto',
               cmap=mycolors, vmin=0, vmax=8)

    ax0.grid(False)
    ax0.spines["left"].set_visible(False)
    ax0.spines["bottom"].set_color('none')
    ax0.spines["bottom"].set_visible(False)


    # Carpet plot
    ax1 = plt.subplot(gs[1])
    ax1.imshow(timeseries, interpolation='nearest', aspect='auto', cmap='gray',
               vmin=v[0], vmax=v[1])

    ax1.grid(False)
    ax1.set_yticks([])
    ax1.set_yticklabels([])

    # Set 10 frame markers in X axis
    interval = max((int(timeseries.shape[-1] + 1) // 10, int(timeseries.shape[-1] + 1) // 5, 1))
    xticks = list(range(0, timeseries.shape[-1])[::interval])
    ax1.set_xticks(xticks)
    ax1.set_xlabel('time')

    # Remove and redefine spines
    for side in ["top", "right"]:
        # Toggle the spine objects
        ax0.spines[side].set_color('none')
        ax0.spines[side].set_visible(False)
        ax1.spines[side].set_color('none')
        ax1.spines[side].set_visible(False)

    ax1.yaxis.set_ticks_position('left')
    ax1.xaxis.set_ticks_position('bottom')
    ax1.spines["bottom"].set_visible(False)
    ax1.spines["left"].set_color('none')
    ax1.spines["left"].set_visible(False)

    if legend:
        gslegend = mgs.GridSpecFromSubplotSpec(
            5, 1, subplot_spec=gs[2], wspace=0.0, hspace=0.0)

        if not background_file:
            background_file = atlas #TODO: works only for 3mm atlas
        background = nb.load(background_file)
        atlas = nb.load(atlas)

        nslices = background.shape[-1]
        coords = [-40, 20, 0, 20, 40]  # works in MNI space
        lut2 = lut
        lut2 = np.array([0] + lut2.tolist())

        relabeled=lut2[np.array(atlas.get_fdata(), dtype=int)]
        atl = nb.Nifti1Image(relabeled, atlas.affine, dtype=np.int64)
        for i, c in enumerate(coords):
            ax2 = plt.subplot(gslegend[i])
            plot_img(atl, bg_img=background, axes=ax2, display_mode='z',
                     annotate=False, cut_coords=[c], threshold=0.1, cmap=mycolors,
                     interpolation='nearest', vmin=1, vmax=7)

    if output_file is not None:
        figure = plt.gcf()
        figure.savefig(output_file, bbox_inches='tight')
        plt.close(figure)
        figure = None
        return os.getcwd() + '/' + output_file

    return [ax0, ax1], gs